// Dependencies
const { mboxReader } = require("mbox-reader");
const { simpleParser } = require("mailparser");
const { createReadStream, writeFileSync } = require("fs");

/**
 * Convert list of in person school days into object ready to accept statistics.
 * @param {String[]} dayList List of YYYY-MM-DD formatted in person school days.
 * @returns {Object} Return an object with each listed day as a key with value {}.
 */
function createInPersonDayObj(dayList) {
  let dayObj = {};
  for (const day of dayList) {
    dayObj[day] = {};
  }
  return dayObj;
}

/**
 * Compute statistics based on notifications received for each school calendar day.
 * @param {Object} obj Object contains processed notifications over layed onto each school day.
 * @returns {Object} Object contains inPersonSchoolDays, expectedTotalStops, radiusNotificationTotal, substitutionNotificationTotal and notificationTotal
 */
function computeStats(obj) {
  const inPersonSchoolDays = Object.keys(obj).length;
  const expectedTotalStops = inPersonSchoolDays * 2; // We expect two stops per day
  let radiusNotificationTotal = 0;
  let substitutionNotificationTotal = 0;
  let notificationTotal = 0;

  for (const key in obj) {
    if (obj[key]) {
      if (obj[key].AM) {
        if (obj[key].AM.notificationTime) {
          radiusNotificationTotal++;
          notificationTotal++;
        }
        if (obj[key].AM.busSubstitution) {
          substitutionNotificationTotal++;
          notificationTotal++;
        }
      }
      if (obj[key].PM) {
        if (obj[key].PM.notificationTime) {
          radiusNotificationTotal++;
          notificationTotal++;
        }
        if (obj[key].PM.busSubstitution) {
          substitutionNotificationTotal++;
          notificationTotal++;
        }
      }
    }
  }

  return {
    inPersonSchoolDays: inPersonSchoolDays,
    expectedTotalStops: expectedTotalStops,
    radiusNotificationTotal: radiusNotificationTotal,
    substitutionNotificationTotal: substitutionNotificationTotal,
    notificationTotal: notificationTotal,
  };
}

/**
 * Convert difference in milliseconds into human readable text.
 * @param {number} differenceMillis Number of milliseconds different from expected time
 * @param {string} plusOrMinus A "+" if late or "-" if early.
 * @returns {string} Text like '(-0:05:57) 05 minutes 57 seconds early'
 */
function differenceMillisToText(differenceMillis, plusOrMinus) {
  let seconds = Math.floor((differenceMillis / 1000) % 60);
  let minutes = Math.floor((differenceMillis / (1000 * 60)) % 60);
  let hours = Math.floor((differenceMillis / (1000 * 60 * 60)) % 24);
  let output = "";

  if (hours > 0) {
    hours = hours < 10 ? "0" + hours : hours;
    output += `${hours} hours `;
  }
  if (minutes > 0) {
    minutes = minutes < 10 ? "0" + minutes : minutes;
    output += `${minutes} minutes `;
  }
  seconds = seconds < 10 ? "0" + seconds : seconds;
  output += `${seconds} seconds`;

  return `${
    "(" + plusOrMinus + hours + ":" + minutes + ":" + seconds + ")"
  } ${output}`;
}

/**
 * Convert Date object into YYYY-MM-DD string.
 * @param {Date} [date=new Date()] Date object to format
 * @returns {string} YYYY-MM-DD formatted date string
 */
function getHyphenFormattedDate(date = new Date()) {
  let d = date;
  const offset = d.getTimezoneOffset();
  d = new Date(d.getTime() - offset * 60 * 1000);
  return d.toISOString().split("T")[0];
}

/**
 * Get human readable text representation of the difference between scheduled and actual arrival time.
 * Note: actual arrival time is not readily available; use radius notification as an approximation.
 * @param {Date} scheduled The scheduled arrival time.
 * @param {Date} actual The actual arrival time.
 * @returns {string} Text similar to (-0:05:57) 05 minutes 57 seconds early
 */
function getRadiusNotificationDeltaAsText(scheduled, actual) {
  // get difference in milliseconds
  let millisDifference = scheduled - actual;
  let plusOrMinus = "";

  // handle early, late, on time
  let description = "";
  if (millisDifference < 0) {
    millisDifference = -1 * millisDifference;
    description = "late";
    plusOrMinus = "+";
  } else if (millisDifference === 0) {
    description = "on time";
    plusOrMinus = "";
  } else {
    description = "early";
    plusOrMinus = "-";
  }

  // Return Human readable text
  return `${differenceMillisToText(
    millisDifference,
    plusOrMinus
  )} ${description}`;
}

/**
 * Format statistics object generated by computeStats() into human readable text.
 * @param {*} obj Object generated by computeStats().
 * @returns {string} Human readable format of statistics object.
 */
function getStatsText(obj) {
  let string = "";
  string += `In person school days: ${obj.inPersonSchoolDays}\n`;
  string += `Total expected bus radius notification: ${obj.expectedTotalStops}\n`;
  string += `Total bus radius notifications received: ${obj.radiusNotificationTotal}\n`;
  string += `Total bus substitution notifications received: ${obj.substitutionNotificationTotal}\n`;
  string += `Total notifications received: ${obj.notificationTotal}\n`;
  string += `Efficacy of radius notifications: ${toPercentString(
    obj.radiusNotificationTotal / obj.expectedTotalStops
  )}`;
  return string;
}

/**
 * This function maps notification objects onto the school calendar up to a certain date.
 * This is necessary because there may be days where no notifications are sent.
 * @param {Object} notifications Object containing processed notification events.
 * @param {Object} calendar Object with dates as keys ready for notifications to be added to.
 * @param {Date} [upToDateStr=new Date()] End date to process up to.
 * @returns {Object} Notifications and school days to to provided date.
 */
function mapBusNotificationsToSchoolDays(
  notifications = {},
  calendar = {},
  upToDateStr = new Date()
) {
  // do not attempt to process dates in the future
  const d = getHyphenFormattedDate(upToDateStr);
  // might as well get the keys in order here
  const keyList = Object.keys(calendar).sort();
  // instantiate object to hold results
  let result = {};

  for (
    let i = 0, key = keyList[i];
    d >= key && i < keyList.length;
    i++, key = keyList[i]
  ) {
    result[key] = notifications[key] || null;
  }

  return result;
}

/**
 * Search mbox for notifications and when found, compute statistics.
 * Overlay all statistics on the school calendar.
 * @param {Object} args Arguments object.
 * @param {String} args.amScheduledArrivalTime The scheduled arrival time in the morning e.g., "06:45:00 EDT".
 * @param {String} args.pmScheduledArrivalTime The scheduled arrival time in the afternoon e.g., "15:45:00 EDT".
 * @param {RegExp} args.regexRadius Regular expression matching the bus stop radius notification.
 * @param {RegExp} args.regexSubstitute Regular expression matching the bus substitution notification.
 * @param {Object} args.inPersonDayObj Object containing keys for school days with empty object values.
 * @param {Boolean} [args.filterFirstName=false] Filter notifications based on first name?
 * @param {Boolean} [args.filterLastName=false] Filter notifications based on last name?
 * @param {Boolean} [args.includeNameBool=false] Include Names in outputfile.json?
 * @param {ReadStream} [args.mboxFilePath=process.stdin] Notifications in mbox format - defaults to standard input.
 * @returns {Object} Statistics overlayed on school calendar.
 */
async function readMbox(args = {}) {
  let amScheduledArrivalTime = args.amScheduledArrivalTime;
  let pmScheduledArrivalTime = args.pmScheduledArrivalTime;
  let regexRadius = args.regexRadius;
  let regexSubstitute = args.regexSubstitute;
  let inPersonDayObj = args.inPersonDayObj || {};
  let filterFirstName = args.filterFirstName || false;
  let filterLastName = args.filterLastName || false;
  let includeNameBool = args.includeNameBool || false;
  let notificationObj = {};

  // Support stdin or specifying a path
  let mboxInputStream;
  if (args.mboxFilePath) {
    mboxInputStream = createReadStream(args.mboxFilePath);
  } else {
    mboxInputStream = process.stdin;
  }

  for await (let message of mboxReader(mboxInputStream)) {
    // Parse the message and look for regex matches
    let parsed = await simpleParser(message.content);
    let radiusMatch = regexRadius.exec(parsed.text);
    let substituteMatch = regexSubstitute.exec(parsed.text);

    // Process Radius Notification
    if (radiusMatch) {
      let busNumber = radiusMatch[1];
      let firstName = radiusMatch[2];
      let lastName = radiusMatch[3];
      let notificationTimestamp =
        new Date(Date.parse(radiusMatch[4])) || parsed.date;
      let yearMonthDay = getHyphenFormattedDate(notificationTimestamp);

      // filter on names for families with multiple children
      if (
        (filterFirstName && firstName != filterFirstName) ||
        (filterLastName && lastName != filterLastName)
      ) {
        continue;
      }

      // handle AM vs. PM for object key
      let midDay = notificationTimestamp.getHours() < 12 ? "AM" : "PM";
      // compute Date for expected arrival time
      let scheduledArrivalTime =
        notificationTimestamp.getHours() < 12
          ? new Date(Date.parse(`${yearMonthDay} ${amScheduledArrivalTime}`))
          : new Date(Date.parse(`${yearMonthDay} ${pmScheduledArrivalTime}`));
      // Make sure an object exists to add notification data to
      if (!notificationObj[yearMonthDay]) {
        notificationObj[yearMonthDay] = {};
      }
      // Add notification data
      notificationObj[yearMonthDay][midDay] = {
        busNumber: busNumber,
        notificationTime: notificationTimestamp,
        scheduledArrivalTime: scheduledArrivalTime,
        deviationText: getRadiusNotificationDeltaAsText(
          scheduledArrivalTime,
          notificationTimestamp
        ),
        deviationSeconds: (notificationTimestamp - scheduledArrivalTime) / 1000, // negative is early, positive is late
      };
      // Add first and last name, if desired
      if (includeNameBool) {
        notificationObj[yearMonthDay][midDay].firstName = firstName;
        notificationObj[yearMonthDay][midDay].lastName = lastName;
      }
    }
    // Process Bus Substitution Notification
    if (substituteMatch) {
      let originalBusNumber = substituteMatch[1];
      let replacementBusNumber = substituteMatch[2];
      let notificationTimestamp = parsed.date;
      let yearMonthDay = getHyphenFormattedDate(notificationTimestamp);
      let midDay = notificationTimestamp.getHours() < 12 ? "AM" : "PM";
      // Make sure a date object exists to add notification data to
      if (!notificationObj[yearMonthDay]) {
        notificationObj[yearMonthDay] = {};
      }
      // Make sure date object includes AM/PM key to add data to
      if (!notificationObj[yearMonthDay][midDay]) {
        notificationObj[yearMonthDay][midDay] = {};
      }
      // Add data from Bus Substitution Notification
      notificationObj[yearMonthDay][midDay]["busSubstitution"] = {
        originalBusNumber: originalBusNumber,
        replacementBusNumber: replacementBusNumber,
      };
    }
  }
  // Map the notification results to school days
  // This step is necessary because there may be school days when no notifications are received.
  let res = mapBusNotificationsToSchoolDays(notificationObj, inPersonDayObj);
  return res;
}

/**
 * WriteFileSync wrapper that generates consistent filename if not passed.
 * This function assumes the path already exists.
 * @param {Object} data Object to stringify and store.
 * @param {string} [filename="./YYYY-MM-DD-statistics.json"] Optionally provide a desired filename.
 * @returns {string} The filename.
 */
function storeResultsInFile(
  data = {},
  filename = `./${getHyphenFormattedDate()}-statistics.json`
) {
  writeFileSync(filename, JSON.stringify(data, null, 2));
  return filename;
}

/**
 * Get a string representation of a numeric percentage.
 * For example, toPercentString(0.4233) returns "42.3 %".
 * @param {number} x A number to format
 * @param {number} [precision=3] Specify the number of digits to print
 * @returns {string} A string representation of a numeric percentage.
 */
function toPercentString(x, precision = 3) {
  return `${Number.parseFloat(x * 100).toPrecision(precision)} %`;
}

module.exports = {
  computeStats: computeStats,
  createInPersonDayObj: createInPersonDayObj,
  differenceMillisToText: differenceMillisToText,
  getHyphenFormattedDate: getHyphenFormattedDate,
  getStatsText: getStatsText,
  getRadiusNotificationDeltaAsText: getRadiusNotificationDeltaAsText,
  mapBusNotificationsToSchoolDays: mapBusNotificationsToSchoolDays,
  readMbox: readMbox,
  storeResultsInFile: storeResultsInFile,
  toPercentString: toPercentString,
};
